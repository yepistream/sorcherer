{"version":3,"file":"index.cjs","sources":["src/sorcherer.js"],"sourcesContent":["// src/sorcherer.js\n\n// Dynamically load magicalStyle.css if not already loaded.\n(function loadMagicalStyle() {\n  if (typeof document !== \"undefined\" && !document.getElementById('magical-style')) {\n    const link = document.createElement('link');\n    link.id = 'magical-style';\n    link.rel = 'stylesheet';\n    // Adjust the path if your structure changes.\n    link.href = '/magicalStyle.css';\n    document.head.appendChild(link);\n  }\n})();\n\nimport { Vector3, Frustum, Matrix4 } from 'three';\n\nclass Sorcherer {\n  // All overlay instances (stored in a Set)\n  static allLoadedElements = new Set();\n  // For frustum culling.\n  static frustum = new Frustum();\n  static matrix = new Matrix4();\n  // Container element for all overlays (null in non-DOM environments).\n  static container = (typeof document !== \"undefined\")\n    ? document.createElement('div')\n    : null;\n  static autoUpdateRunning = false;\n  // Registry mapping Object3D names to objects.\n  static objectRegistry = new Map();\n  // Global dictionary mapping idm (i.e. Object3D name) to overlay instance.\n  static instancesById = {};\n  // Alias for instancesById.\n  static get elements() { return Sorcherer.instancesById; }\n  // Default scale multiplier (developers can change this via Sorcherer.defaultScaleMultiplier).\n  static defaultScaleMultiplier = 1;\n\n  // Static initializer: attach the overlay container.\n  static {\n    if (typeof document !== \"undefined\" && Sorcherer.container) {\n      Sorcherer.container.classList.add('sorcherer-container');\n      document.body.appendChild(Sorcherer.container);\n    }\n  }\n\n  /**\n   * @param {THREE.Object3D} object - The target Object3D.\n   * @param {THREE.Vector3} [offset=new Vector3()] - Optional offset for the overlay.\n   * @param {boolean} [simulate3D=false] - Whether to scale the overlay based on distance.\n   * @param {boolean} [simulateRotation=false] - Whether to rotate the overlay with the object.\n   * @param {boolean} [autoCenter=false] - Whether to auto-center the overlay relative to its computed screen position.\n   * @param {number} [scaleMultiplier] - Multiplier for distance-based scaling (defaults to Sorcherer.defaultScaleMultiplier).\n   */\n  constructor(object, offset = new Vector3(), simulate3D = false, simulateRotation = false, autoCenter = false, scaleMultiplier) {\n    this.object = object;\n    this.offset = offset;\n    this.simulate3D = simulate3D;\n    this.simulateRotation = simulateRotation;\n    this.autoCenter = autoCenter;\n    this.scaleMultiplier = (scaleMultiplier !== undefined) ? scaleMultiplier : Sorcherer.defaultScaleMultiplier;\n    this._parentSpan = this.createSpan();\n    this.innerHTML = \"\";\n    \n    // For dynamic variables: store the original template and dynamicVars.\n    this.template = \"\";\n    this.dynamicVars = {};\n\n    if (typeof document !== \"undefined\" && Sorcherer.container) {\n      Sorcherer.container.appendChild(this._parentSpan);\n      Sorcherer.allLoadedElements.add(this);\n    }\n\n    // Auto-remove overlay when the Object3D is removed from its parent.\n    if (this.object) {\n      const originalOnRemoved = this.object.onRemovedFromParent;\n      this.object.onRemovedFromParent = () => {\n        if (originalOnRemoved) originalOnRemoved();\n        this.dispose();\n      };\n    }\n  }\n\n  createSpan() {\n    if (typeof document === \"undefined\") {\n      // Minimal stub for non-DOM environments.\n      return {\n        style: {},\n        classList: { add() {} },\n        innerHTML: ''\n      };\n    }\n    const span = document.createElement('span');\n    span.classList.add('magic-MinusOne');\n    span.style.position = 'absolute';\n    span.style.display = 'none';\n    span.style.transformOrigin = 'top left';\n    return span;\n  }\n\n  /**\n   * Attaches HTML content to the overlay.\n   * Dynamic variable placeholders follow the syntax:\n   *    $varName$  or  $varName=defaultValue$\n   *\n   * This method parses the template, stores dynamic variables, and renders the content.\n   * @param {string} innerHTML - The HTML content to display.\n   */\n  attach(innerHTML) {\n    // Save the template.\n    this.template = innerHTML;\n    this.dynamicVars = {};\n    // Regex to match $varName$ or $varName=defaultValue$.\n    const regex = /\\$([a-zA-Z0-9_]+)(?:=([^$]+))?\\$/g;\n    // First pass: extract dynamic variables and defaults.\n    this.template.replace(regex, (match, varName, defaultVal) => {\n      if (!(varName in this.dynamicVars)) {\n        this.dynamicVars[varName] = (defaultVal !== undefined) ? defaultVal : '';\n      }\n      // Define getter/setter for direct property access.\n      Object.defineProperty(this, varName, {\n        get: () => this.getDynamicVar(varName),\n        set: (value) => { this.setDynamicVar(varName, value); },\n        enumerable: true,\n        configurable: true\n      });\n      return match;\n    });\n    this.renderDynamicVars();\n    this._parentSpan.style.display = 'block';\n  }\n\n  /**\n   * Renders the overlay content by replacing placeholders with current dynamic variable values.\n   */\n  renderDynamicVars() {\n    const rendered = this.template.replace(/\\$([a-zA-Z0-9_]+)(?:=[^$]+)?\\$/g, (match, varName) => {\n      return (this.dynamicVars[varName] !== undefined) ? this.dynamicVars[varName] : '';\n    });\n    this._parentSpan.innerHTML = rendered;\n  }\n\n  /**\n   * Sets the value of a dynamic variable and re-renders the overlay.\n   * @param {string} varName - The variable name.\n   * @param {string} value - The new value.\n   */\n  setDynamicVar(varName, value) {\n    this.dynamicVars[varName] = value;\n    this.renderDynamicVars();\n  }\n\n  /**\n   * Gets the current value of a dynamic variable.\n   * @param {string} varName - The variable name.\n   * @returns {string} The value.\n   */\n  getDynamicVar(varName) {\n    return this.dynamicVars[varName];\n  }\n\n  /**\n   * Updates the overlayâ€™s position, scaling (based on distance), and rotation.\n   * @param {THREE.Camera} camera - The active camera.\n   * @param {THREE.Renderer} renderer - The active renderer.\n   */\n  bufferInstance(camera, renderer) {\n    if (!this.object) return;\n    if (!this.object.visible) {\n      this._parentSpan.style.display = 'none';\n      return;\n    }\n\n    // Get the object's world position and add the offset.\n    const objectWorldPos = new Vector3();\n    this.object.getWorldPosition(objectWorldPos);\n    objectWorldPos.add(this.offset);\n\n    // Compute the Euclidean distance from the camera.\n    let distance = camera.position.distanceTo(objectWorldPos);\n    // Avoid division by zero / Infinity scales.\n    if (!isFinite(distance) || distance <= 0) distance = 0.0001;\n\n    // Project the position to screen space.\n    const projectedPos = objectWorldPos.clone();\n    projectedPos.project(camera);\n\n    const widthHalf = renderer.domElement.clientWidth / 2;\n    const heightHalf = renderer.domElement.clientHeight / 2;\n    const x = widthHalf * (projectedPos.x + 1);\n    const y = heightHalf * (1 - projectedPos.y);\n\n    // Build the transform string.\n    let transform = `translate(${x}px, ${y}px)`;\n    if (this.autoCenter) {\n      transform += ' translate(-50%, -50%)';\n    }\n\n    // Apply distance-based scaling if enabled.\n    if (this.simulate3D) {\n      const referenceDistance = 5;\n      const scale = Math.max(0.1, this.scaleMultiplier * (referenceDistance / distance));\n      transform += ` scale(${scale})`;\n    }\n\n    // Apply rotation as part of the transform if enabled.\n    if (this.simulateRotation) {\n      const angleDeg = this.object.rotation.z * (180 / Math.PI);\n      transform += ` rotate(${angleDeg}deg)`;\n    }\n\n    this._parentSpan.style.transform = transform;\n\n    // Adjust z-index based on distance.\n    this._parentSpan.style.zIndex = Math.round(1000 / distance).toString();\n    this._parentSpan.style.display = 'block';\n  }\n\n  /**\n   * Updates all overlays based on the active camera and renderer.\n   * Performs frustum culling.\n   * @param {THREE.Camera} camera - The active camera.\n   * @param {THREE.Renderer} renderer - The active renderer.\n   */\n  static bufferAll(camera, renderer) {\n    if (!camera || !renderer) return;\n\n    Sorcherer.matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    Sorcherer.frustum.setFromProjectionMatrix(Sorcherer.matrix);\n\n    for (let element of Sorcherer.allLoadedElements) {\n      if (!element.object) {\n        if (element._parentSpan && element._parentSpan.style) {\n          element._parentSpan.style.display = 'none';\n        }\n        continue;\n      }\n      const worldPos = new Vector3();\n      element.object.getWorldPosition(worldPos);\n      if (Sorcherer.frustum.containsPoint(worldPos)) {\n        element.bufferInstance(camera, renderer);\n      } else if (element._parentSpan && element._parentSpan.style) {\n        element._parentSpan.style.display = 'none';\n      }\n    }\n  }\n\n  /**\n   * Starts the auto-update loop.\n   * @param {THREE.Camera} camera - The active camera.\n   * @param {THREE.Renderer} renderer - The active renderer.\n   * @param {number} [interval=16] - Minimum milliseconds between updates.\n   */\n  static autoSetup(camera, renderer, interval = 16) {\n    if (Sorcherer.autoUpdateRunning || !camera || !renderer) return;\n    Sorcherer.autoUpdateRunning = true;\n\n    const useRaf = (typeof requestAnimationFrame === 'function');\n\n    if (useRaf) {\n      let lastTime = 0;\n      const loop = (time) => {\n        if (!Sorcherer.autoUpdateRunning) return;\n        if (!lastTime || time - lastTime >= interval) {\n          lastTime = time;\n          Sorcherer.bufferAll(camera, renderer);\n        }\n        requestAnimationFrame(loop);\n      };\n      requestAnimationFrame(loop);\n    } else {\n      const loop = () => {\n        if (!Sorcherer.autoUpdateRunning) return;\n        Sorcherer.bufferAll(camera, renderer);\n        setTimeout(loop, interval);\n      };\n      loop();\n    }\n  }\n\n  static stopAutoSetup() {\n    Sorcherer.autoUpdateRunning = false;\n  }\n\n  /**\n   * Removes the overlay and cleans up references.\n   */\n  dispose() {\n    if (this._parentSpan.parentElement) {\n      this._parentSpan.parentElement.removeChild(this._parentSpan);\n    }\n    Sorcherer.allLoadedElements.delete(this);\n    if (this.object && this.object.name && Sorcherer.instancesById[this.object.name]) {\n      delete Sorcherer.instancesById[this.object.name];\n    }\n  }\n\n  /**\n   * Registers a Three.js Object3D using its name as the key.\n   * @param {THREE.Object3D} object - The object to register.\n   */\n  static registerObject3D(object) {\n    if (object && object.name) {\n      Sorcherer.objectRegistry.set(object.name, object);\n    }\n  }\n\n  /**\n   * Convenience: register all named objects in a scene (or any Object3D subtree).\n   * @param {THREE.Object3D} scene - Root to traverse.\n   */\n  static registerScene(scene) {\n    if (!scene || typeof scene.traverse !== 'function') return;\n    scene.traverse(obj => {\n      if (obj && obj.name) {\n        Sorcherer.registerObject3D(obj);\n      }\n    });\n  }\n\n  /**\n   * High-level convenience: register all named objects in a scene,\n   * attach overlays from <realm>, and start the auto-update loop.\n   *\n   * This replaces manual calls to:\n   *   Sorcherer.registerObject3D(...)\n   *   Sorcherer.attachFromRealm()\n   *   Sorcherer.autoSetup(camera, renderer)\n   *\n   * @param {THREE.Scene} scene\n   * @param {THREE.Camera} camera\n   * @param {THREE.Renderer} renderer\n   * @param {Object} [options]\n   * @param {number} [options.interval=16]  Min ms between updates.\n   * @param {boolean} [options.autoAttach=true]  Call attachFromRealm().\n   * @param {boolean} [options.autoRegister=true]  Call registerScene().\n   */\n  static bootstrap(scene, camera, renderer, options = {}) {\n    const {\n      interval = 16,\n      autoAttach = true,\n      autoRegister = true,\n    } = options;\n\n    if (!camera || !renderer) {\n      console.warn('[Sorcherer] bootstrap() requires a camera and renderer.');\n      return;\n    }\n\n    if (autoRegister) {\n      Sorcherer.registerScene(scene);\n    }\n\n    if (autoAttach && typeof document !== 'undefined') {\n      Sorcherer.attachFromRealm();\n    }\n\n    Sorcherer.autoSetup(camera, renderer, interval);\n  }\n\n  /**\n   * Scans the DOM for custom <realm> tags. For each child element with an \"idm\" attribute,\n   * this method looks up the registered Object3D and reads additional attributes:\n   * - simulate3D: \"true\" enables distance-based scaling.\n   * - simulateRotation: \"true\" enables rotation via CSS transform.\n   * - offset: A comma-separated list (e.g., \"0,0.5,0\") defining a THREE.Vector3 offset.\n   * - autoCenter: \"true\" centers the overlay relative to its computed position.\n   * - scaleMultiplier: A number to multiply the computed scale factor.\n   * The overlay's content may include dynamic variable placeholders.\n   *\n   * @param {Document|Element} [root=document] - Optional root node to search within.\n   */\n  static attachFromRealm(root = document) {\n    if (typeof document === \"undefined\") return;\n    const rootNode = root || document;\n    const realmElements = rootNode.querySelectorAll('realm');\n    if (!realmElements.length) return;\n\n    realmElements.forEach((realmElement) => {\n      const elements = realmElement.querySelectorAll('[idm]');\n      elements.forEach(el => {\n        const idm = el.getAttribute('idm');\n        if (!idm) return;\n        const object = Sorcherer.objectRegistry.get(idm);\n        if (!object) return;\n\n        const simulate3D = (el.getAttribute('simulate3D') || '').toLowerCase() === 'true';\n        const simulateRotation = (el.getAttribute('simulateRotation') || '').toLowerCase() === 'true';\n        const autoCenter = (el.getAttribute('autoCenter') || '').toLowerCase() === 'true';\n\n        let offset = new Vector3();\n        if (el.hasAttribute('offset')) {\n          const offsetStr = el.getAttribute('offset');\n          const parts = offsetStr.split(',').map(s => parseFloat(s.trim()));\n          if (parts.length >= 3 && parts.every(n => !isNaN(n))) {\n            offset = new Vector3(parts[0], parts[1], parts[2]);\n          }\n        }\n\n        let scaleMultiplier;\n        if (el.hasAttribute('scaleMultiplier')) {\n          const parsed = parseFloat(el.getAttribute('scaleMultiplier'));\n          if (!isNaN(parsed)) {\n            scaleMultiplier = parsed;\n          }\n        }\n\n        const instance = new Sorcherer(object, offset, simulate3D, simulateRotation, autoCenter, scaleMultiplier);\n        instance.attach(el.innerHTML);\n        el.remove();\n        if (object.name) {\n          Sorcherer.instancesById[object.name] = instance;\n        }\n      });\n\n      if (realmElement.children.length === 0) {\n        realmElement.remove();\n      }\n    });\n  }\n\n  /**\n   * Clones the current overlay instance and attaches the clone to the specified Object3D.\n   * @param {THREE.Object3D} targetObject - The target Object3D to attach the clone.\n   * @param {string} newName - The new name for the cloned overlay (and the target Object3D).\n   * @returns {Sorcherer} The cloned overlay instance.\n   */\n  attachClone(targetObject, newName) {\n    const clone = new Sorcherer(\n      targetObject,\n      this.offset,\n      this.simulate3D,\n      this.simulateRotation,\n      this.autoCenter,\n      this.scaleMultiplier\n    );\n    clone.template = this.template;\n    // Shallow-clone dynamicVars.\n    clone.dynamicVars = { ...this.dynamicVars };\n    clone.renderDynamicVars();\n    if (newName) {\n      targetObject.name = newName;\n      Sorcherer.instancesById[newName] = clone;\n    }\n    return clone;\n  }\n}\n\nexport { Sorcherer };\n"],"names":[],"mappings":""}